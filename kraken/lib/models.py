"""
kraken.lib.models
~~~~~~~~~~~~~~~~~

Wraps around legacy pyrnn and protobuf models to provide a single interface. In
the future it will also include support for clstm models.
"""

from __future__ import absolute_import
from __future__ import unicode_literals
from future import standard_library
standard_library.install_aliases()
from future.utils import PY2

from os.path import expandvars, expanduser, abspath

from builtins import next
from builtins import chr

import torch
import numpy
import gzip
import bz2
import sys
import io

import kraken.lib.lineest

from kraken.lib import pyrnn_pb2
from kraken.lib.vgsl import TorchVGSLModel
from kraken.lib.exceptions import KrakenInvalidModelException, KrakenInputException
from torch.autograd import Variable

class TorchSeqRecognizer(object):
    """
    A class wrapping a TorchVGSLModel with a more comfortable recognition interface.
    """
    def __init__(self, nn):
        self.nn = nn
        self.codec = nn.codec

    def forward(self, line):
        """
        Performs a forward pass on a numpy array of a line with shape (C, H, W)
        and returns a numpy array (W, C).
        """
        line = Variable(torch.FloatTensor(line))
        # make NCHW -> 1CHW
        line.unsqueeze_(0)
        o = self.nn.nn(line)
        if o.size(2) != 1:
            raise KrakenInputException('Expected dimension 3 to be 1, actual {}'.format(output.size()))
        self.outputs = o.data.squeeze().transpose(0, 1).numpy()
        return self.outputs

    def predict(self, line):
        """
        Performs a forward pass on a numpy array of a line with shape (C, H, W)
        and returns the decoding as a list of tuples (string, start, end,
        confidence).
        """
        o = self.forward(line)
        locs = self.translate_back_locations(o)
        return self.codec.decode(locs)

    def predictString(self, line):
        """
        Performs a forward pass on a numpy array of a line with shape (C, H, W)
        and returns astring of the results.
        """
        o = self.forward(line)
        locs = self.translate_back_locations(o)
        decoding = self.codec.decode(locs)
        return ''.join(x[0] for x in decoding)

    def translate_back_locations(self, output, threshold=0.5):
        """
        Translates an output array of shape (C, W) into a label sequence
        with their corresponding time steps.

        Args:
            output (numpy.array): (C, W) shaped softmax output tensor
            threshold (float): Threshold for 0 class when determining possible
                               label locations.

        Returns:
            A list with tuples (class, start, end, max). max is the maximum value
            of the softmax layer in the region.
        """
        return kraken.lib.ctc_decoder.translate_back_locations(output, threshold)

    def translate_back(self, output):
        """
        Translates an output tensor of shape (1, C, 1, W) into a label sequence.

        Args:
            output (torch.Tensor): (1, C, 1, W) shaped softmax output tensor
            threshold (float): Threshold for 0 class when determining possible
                               label locations.

        Returns:
            A list of integer labels.
        """
        return kraken.lib.ctc_decoder.translate_back(output, threshold)


def load_any(fname):
    """
    Loads anything that was, is, and will be a valid ocropus model and
    instantiates a shiny new kraken.lib.lstm.SeqRecognizer from the RNN
    configuration in the file.

    Currently it recognizes the following kinds of models:
        * pyrnn models containing BIDILSTMs
        * protobuf models containing converted python BIDILSTMs
        * protobuf models containing CLSTM networks

    Additionally an attribute 'kind' will be added to the SeqRecognizer
    containing a string representation of the source kind. Current known values
    are:
        * pyrnn for pickled BIDILSTMs
        * clstm for protobuf models generated by clstm

    Args:
        fname (unicode): Path to the model

    Returns:
        A kraken.lib.models.TorchSeqRecognizer object.
    """
    nn = None
    kind = ''
    fname = abspath(expandvars(expanduser(fname)))
    try:
        nn = TorchVGSLModel.load_model(fname)
        kind = 'vgsl'
    except:
        try:
            nn = TorchVGSLModel.load_clstm_model(fname)
            kind = 'clstm'
        except:
            nn = TorchVGSLModel.load_pronn_model(fname)
            kind = 'pronn'
        try:
            if not PY2:
                raise KrakenInvalidModelException('Loading pickle models is not '
                                                  'supported on python 3')
            nn = TorchVGSLModel.load_pyrnn_model(fname)
            kind = 'pyrnn'
        except:
            pass
    if not nn:
        raise KrakenInvalidModelException('File {} not loadable by any parser.'.format(fname))
    seq = TorchSeqRecognizer(nn)
    seq.kind = kind
    return seq
