"""
kraken.lib.models
~~~~~~~~~~~~~~~~~

Wrapper around TorchVGSLModel including a variety of forward pass 
Wraps around legacy pyrnn and protobuf models to provide a single interface.
"""

from __future__ import absolute_import
from __future__ import unicode_literals
from future import standard_library
standard_library.install_aliases()
from future.utils import PY2

from os.path import expandvars, expanduser, abspath

from builtins import next
from builtins import chr

import sys
import torch

import kraken.lib.lineest
import kraken.lib.ctc_decoder

from kraken.lib import pyrnn_pb2
from kraken.lib.vgsl import TorchVGSLModel
from kraken.lib.exceptions import KrakenInvalidModelException, KrakenInputException
from torch.autograd import Variable

class TorchSeqRecognizer(object):
    """
    A class wrapping a TorchVGSLModel with a more comfortable recognition interface.
    """
    def __init__(self, nn, decoder=kraken.lib.ctc_decoder.blank_threshold_decoder, train=False):
        """
        Constructs a sequence recognizer from a VGSL model and a decoder.

        Args:
            nn (kraken.lib.vgsl.TorchVGSLModel): neural network used for recognition
            decoder (func): Decoder function used for mapping softmax
                            activations to labels and positions
            train (bool): Enables or disables gradient calculation
        """
        self.nn = nn
        if train:
            self.nn.train()
        else:
            self.nn.eval()
        self.codec = nn.codec
        self.decoder = decoder
        self.train = train

    def forward(self, line):
        """
        Performs a forward pass on a numpy array of a line with shape (C, H, W)
        and returns a numpy array (W, C).
        """
        line = Variable(torch.FloatTensor(line), volatile=not train)
        # make NCHW -> 1CHW
        line.unsqueeze_(0)
        o = self.nn.nn(line)
        if o.size(2) != 1:
            raise KrakenInputException('Expected dimension 3 to be 1, actual {}'.format(output.size()))
        self.outputs = o.data.squeeze().transpose(0, 1).numpy()
        return self.outputs

    def predict(self, line):
        """
        Performs a forward pass on a numpy array of a line with shape (C, H, W)
        and returns the decoding as a list of tuples (string, start, end,
        confidence).
        """
        o = self.forward(line)
        locs = self.decoder(o)
        return self.codec.decode(locs)

    def predict_string(self, line):
        """
        Performs a forward pass on a numpy array of a line with shape (C, H, W)
        and returns a string of the results.
        """
        o = self.forward(line)
        locs = self.decoder(o)
        decoding = self.codec.decode(locs)
        return ''.join(x[0] for x in decoding)

    def predict_labels(self, line):
        """
        Performs a forward pass on a numpy array of a line with shape (C, H, W)
        and returns a list of tuples (class, start, end, max). Max is the
        maximum value of the softmax layer in the region.
        """
        o = self.forward(line)
        return self.decoder(o)


def load_any(fname, train=False):
    """
    Loads anything that was, is, and will be a valid ocropus model and
    instantiates a shiny new kraken.lib.lstm.SeqRecognizer from the RNN
    configuration in the file.

    Currently it recognizes the following kinds of models:
        * pyrnn models containing BIDILSTMs
        * protobuf models containing converted python BIDILSTMs
        * protobuf models containing CLSTM networks

    Additionally an attribute 'kind' will be added to the SeqRecognizer
    containing a string representation of the source kind. Current known values
    are:
        * pyrnn for pickled BIDILSTMs
        * clstm for protobuf models generated by clstm

    Args:
        fname (unicode): Path to the model
        train (bool): Enables gradient calculation and dropout layers in model.

    Returns:
        A kraken.lib.models.TorchSeqRecognizer object.
    """
    nn = None
    kind = ''
    fname = abspath(expandvars(expanduser(fname)))
    try:
        nn = TorchVGSLModel.load_model(fname, train)
        kind = 'vgsl'
    except:
        try:
            nn = TorchVGSLModel.load_clstm_model(fname, train)
            kind = 'clstm'
        except:
            nn = TorchVGSLModel.load_pronn_model(fname, train)
            kind = 'pronn'
        try:
            if not PY2:
                raise KrakenInvalidModelException('Loading pickle models is not '
                                                  'supported on python 3')
            nn = TorchVGSLModel.load_pyrnn_model(fname, train)
            kind = 'pyrnn'
        except:
            pass
    if not nn:
        raise KrakenInvalidModelException('File {} not loadable by any parser.'.format(fname))
    seq = TorchSeqRecognizer(nn, train=train)
    seq.kind = kind
    return seq
